<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, user-scalable=no" />
  <title>Press and Hold</title>

  <script src="./progressbar.min.js"></script>

  <link rel="stylesheet" type="text/css" href="https://csshake.surge.sh/csshake.min.css">

  <style>
    body {
      background-image: url("bg.png");
      background-color: #cccccc;
    }

    #debug {
      background-color: #0099FF;
      margin-bottom: 100px;
      width: 265px;
      padding: 21px;
      float: right;
    }

    #container {
      height: 100vh;
    }



    /*#item:active {*/
    /*  border-color: #003A75;*/
    /*  background-color: #F2F5EA;*/
    /*}*/

    /*#item:hover {*/
    /*  cursor: pointer;*/
    /*}*/

    .border-green {
      border-color: #1c9a14!important;
    }

    .border-yellow {
      border-color: #bdbb3a!important;
    }

    .border-red {
      border-color: #9d0b0b!important;
    }

    .pulsing {
      animation: border-pulsate 2s infinite;
    }

    .pulsing-red {
      animation: border-pulsate-red 0.5s infinite;
    }

    .progressbar-text {
      color:black!important;
    }

    @keyframes border-pulsate {
      0%   { border-color: rgba(0, 102, 204, 1); }
      50% { border-color: rgba(0, 255, 255, 0); }
      100%   { border-color: rgba(0, 102, 204, 1); }
    }

    @keyframes border-pulsate-red {
      0%   { border-color: rgb(236, 24, 54); }
      50%  { border-color: rgba(0, 255, 255, 0); }
      100% { border-color: rgb(236, 24, 54); }
    }

    @-webkit-keyframes borderBlink {
      from, to {
        border-color: transparent
      }
      50% {
        border-color: black
      }
    }

    @keyframes borderBlink {
      from, to {
        border-color: transparent
      }
      50% {
        border-color: red
      }
    }

    .borderBlink {
      border:1px solid red;
      -webkit-animation: borderBlink 0.1s step-end infinite;
      animation: borderBlink 0.1s step-end infinite;
      /* add 'border-color: transparent' if you wish no border to show initially */
    }

    @keyframes flash_border {
      0% {
        border-color: red;
      }
      50% {
        border-color: black;
      }
      100% {
        border-color: red;
      }
    }

    @-webkit-keyframes flash_border {
      0% {
        border-color: red;
      }
      50% {
        border-color: black;
      }
      100% {
        border-color: red;
      }
    }

    @-moz-keyframes flash_border {
      0% {
        border-color: red;
      }
      50% {
        border-color: black;
      }
      100% {
        border-color: red;
      }
    }

    #itemContainer {
      width: 50px;
      height: 50px;
      position: absolute!important; /*Can also be `fixed`*/
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      margin: auto;
    }

    #circle {
      width: 40px;
      height: 40px;
      position: absolute!important; /*Can also be `fixed`*/
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      margin: auto;
    }

    #item {
      /*--scale-value: 1;*/
      width: 40px;
      height: 40px;
      border: 3px solid #0066CC;
      border-radius: 50%;
      position: absolute!important; /*Can also be `fixed`*/
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      margin: auto;


      display:inline-block;
      font-size: 20px;
      line-height: 40px;
      /*background-color:black;*/
      color:white;
      text-align: center;
      vertical-align: bottom;

      /*transform: scale3d(var(--scale-value), var(--scale-value), 1);*/
      /*transition: transform cubic-bezier(0.175, 0.885, 0.32, 1.275) .2s;*/
    }

    .hook-icon {
      display: inline-block;
      background-image: url("hook.png");
      background-size: contain;
      margin-top: 10px;
      width: 20px;
      height: 20px;
      filter: invert(100%);
      -webkit-filter: invert(100%);
    }
  </style>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta2/css/all.min.css" integrity="sha512-YWzhKL2whUzgiheMoBFwW8CKV4qpHQAEuvilg9FAn5VJUDwKZZxkJNuGM4XkWuk94WCrrwslk8yWNGmY1EduTA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
</head>
<body>
<div id="container">
  <div id="debug">
    <span id="totalTime"></span><br>
    <span id="maxGameTime"></span><br>
    <span id="currentState"></span><br>
    <span id="waitTime"></span><br>
    <span id="pullNeeded"></span><br>
    <span id="currentTension"></span><br>
    <button id="startGame" onclick="startGame()">start game</button><br>
  </div>


  <div id="itemContainer">
    <div id="item">
      <div id="iconContainer"></div>
      <i id="fishIcon" style="display:none;" class="fa-solid fa-fish"></i>
      <i id="lostIcon" style="display:none; color: rgb(236, 24, 54)" class="fas fa-times"></i>
      <i id="okIcon" style="display:none; color: #1c9a14" class="fas fa-check"></i>
    <div id="circle"></div>
  </div>
</div>
<script>


  // var custom = new ProgressBar.Path('#custom', {
  //   easing: 'easeInOut',
  //   duration: 2000
  // });
  //
  // custom.set(0);
  // custom.animate(1.0);


  var circle = new ProgressBar.Circle('#circle', {
    strokeWidth: 8,
    easing: 'easeInOut',
    // duration: 1400,
    trailWidth: 6,
    color: '#0066CC',
    // trailColor: '#eee',
    svgStyle: null,
    text: {
      value:''
    }
  });
  // circle.set(0)


  // circle.animate(1.0);  // Number from 0.0 to 1.0
  var startingTime
  var totalElapsedTime
  var elapsedTimeSinceHooking

  let game = {
    state: 'inactive',
    waitTime: 0,
    pullTime: 0,
    maxGameTime: 0,
    config: {
      timeToHook: 1070000,
      minWait: 1000,
      maxWait: 5000,
      minPull: 200,
      maxPull: 800,
    }
  }

  let container = document.querySelector("#container")
  let itemContainer = document.querySelector("#itemContainer")
  let iconContainer = document.querySelector("#iconContainer")
  let dragItem = document.querySelector("#item")
  let fishIcon = document.querySelector("#fishIcon")
  let lostIcon = document.querySelector("#lostIcon")
  let okIcon = document.querySelector("#okIcon")
  let timePressed = 0
  let currentSize = 0
  let press = false

  let debugTotalTime = document.querySelector("#totalTime");
  let debugMaxGameTime = document.querySelector("#maxGameTime");
  let debugCurrentTension = document.querySelector("#currentTension");
  let debugCurrentState = document.querySelector("#currentState");
  let debugPullNeeded = document.querySelector("#pullNeeded");
  let debugWaitTime = document.querySelector("#waitTime");

  container.addEventListener("mousedown", pressingDown, false);
  container.addEventListener("mouseup", notPressingDown, false);
  container.addEventListener("touchstart", pressingDown, false);
  container.addEventListener("touchend", notPressingDown, false);

  // startGame()


  function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  async function ticker(currentTime) {
    updateDebug()

    if (game.state === 'inactive') {
      reset()
      return
    }

    if (game.state === 'lost') {
      // alert('game stopped, lost ' + totalElapsedTime)
      return
    }

    // pressed in waiting state
    if (game.waitTime < totalElapsedTime && game.state === 'waiting') {
      console.log('// pressed in waiting state', game.waitTime, totalElapsedTime);

      setGameHooking()
    }

    if (elapsedTimeSinceHooking + game.config.timeToHook < totalElapsedTime && game.state === 'hooking') {
      setGameLost('missed hook')
      return
    }

    // pressed in waiting state
    if (game.pullTime < timePressed && game.state === 'pulling') {
      setGameWin()
      return
    }

    if (press) {
      timePressed++;
      currentSize++;

      if (game.state === 'waiting') {
        setGameLost('mouse pressed in waiting state')
        return
      }

      // pressed in waiting state
      if (game.state === 'waiting') {
        setGameLost('mouse pressed not in waiting state')
        return
      }

      // pressed in waiting state
      if (game.state === 'hooking') {
        await setGamePulling()
      }

      circle.set(normalizeCurrentPull())
      scaleItem();
    } else {
      // timePressed = 0;
    }

    if(!startingTime) {
      startingTime = currentTime
    }

    totalElapsedTime = currentTime - startingTime

    requestAnimationFrame(ticker);
  }

  // ticker(0);

  function pressingDown(e) {
    e.preventDefault();
    if (e.button !== 0) {
      return;
    }

    press = true;
  }

  function notPressingDown(e) {
    e.preventDefault();

    if (e.button !== 0) {
      return;
    }

    press = false;
    resetItem();
  }

  function scaleItem() {
    let size = 1 + currentSize / 500;

    if (size > 1.5) {
      size = 1.5;
    }

    pullingCss(size)
    // dragItem.style.transitionDuration = "0s";
    // dragItem.style.setProperty("--scale-value", size);
  }

  function resetItem() {
    console.log('reset item')
    // dragItem.style.transitionDuration = ".2s"
    // dragItem.style.setProperty("--scale-value", 1)
    itemContainer.classList.remove("shake-constant")
    itemContainer.classList.remove("shake-slow")
    itemContainer.classList.remove("shake-little")
    currentSize = 0

    // dragItem.classList.remove("border-green")
    // dragItem.classList.remove("border-yellow")
    // dragItem.classList.remove("border-red")
  }

  function reset()
  {
    itemContainer.style.display = "none";
    hookingCss(false)
    waitingCss(false)
    pullingCss(0, false)

    timePressed = 0
    elapsedTimeSinceHooking = 0
    timePressed = 0
    totalElapsedTime = 0
    startingTime = 0

    setState('inactive')
  }


  function startGame()
  {
    reset()
    itemContainer.style.display = "block";


    game.waitTime = Math.floor(Math.random() * (game.config.maxWait - game.config.minWait + 1)) + game.config.minWait;
    game.pullTime = Math.floor(Math.random() * (game.config.maxPull - game.config.minPull + 1)) + game.config.minPull;
    game.maxGameTime = game.waitTime + game.pullTime + 2000

    setState('waiting')
    waitingCss()
    ticker(0);
  }


  function setGameHooking()
  {
    waitingCss(false)
    hookingCss()
    setState('hooking')

    elapsedTimeSinceHooking = totalElapsedTime
  }

  async function setGamePulling()
  {
    circle.set(0)
    circle.animate(1.0, {duration: 500})
    await sleep(500);
    hookingCss(false)
    circle.set(0)
    setState('pulling')
  }


  async function setGameLost(reason)
  {
    console.log('game lost: ', reason)

    dragItem.classList.remove("border-green")
    dragItem.classList.remove("border-yellow")
    dragItem.classList.remove("pulsing")
    dragItem.classList.add("border-red")

    fishIcon.style.display = "none";

    dragItem.classList.add("border-red")
    lostIcon.style.display = "inline-block";

    circle.animate(0.0, {duration: 700})
    await sleep(700);

    lostIcon.style.display = "none";
    dragItem.classList.remove("border-red")

    setState('lost')
    reset()
  }

  async function setGameWin()
  {
    dragItem.classList.remove("pulsing")
    dragItem.classList.remove("border-green")
    dragItem.classList.remove("border-yellow")
    dragItem.classList.remove("pulsing")
    dragItem.classList.remove("border-red")

    fishIcon.style.display = "none";
    lostIcon.style.display = "none";

    okIcon.style.display = "inline-block";

    circle.animate(0.0, {duration: 700})
    await sleep(700);

    okIcon.style.display = "none";



    setState('win')
    reset()
  }

  function updateDebug()
  {
    debugCurrentState.textContent = 'Game State: ' + game.state;
    debugTotalTime.textContent = 'TotalElapsedTime: ' + Math.round(totalElapsedTime) + ' ms';
    debugMaxGameTime.textContent = 'Max Game time : ' + game.maxGameTime + ' ms';
    debugWaitTime.textContent = 'Wait Time: ' +  game.waitTime + ' ms';
    debugPullNeeded.textContent = 'Pull time needed: ' +  game.pullTime;
    debugCurrentTension.textContent = 'Current pull time: ' +  timePressed +' (' + Math.round(normalizeCurrentPull() * 100) + '%)';
    // circle.setText(game.state)
  }


  /**
   *  normalized current pull value in 0-1 range with 4 decimals
   *
   * @returns {string|number}
   */
  function normalizeCurrentPull() {
    if (timePressed === 0 || game.pullTime === 0) {
      return 0
    }

    return  (timePressed / game.pullTime).toFixed(4)
  }

  function waitingCss(activate = true)
  {
    if (activate) {
      dragItem.classList.add("pulsing");
    } else {
      dragItem.classList.remove("pulsing");
    }
  }

  function hookingCss(activate = true)
  {
    if (activate) {
      dragItem.classList.add("pulsing-red")
      iconContainer.classList.add("shake-constant")
      iconContainer.classList.add("shake-little")
      iconContainer.classList.add("hook-icon")
    } else {
      dragItem.classList.remove("pulsing-red")
      iconContainer.classList.remove("shake-constant")
      iconContainer.classList.remove("shake-little")
      iconContainer.classList.remove("hook-icon")

    }
  }

  function pullingCss(size, activate = true)
  {
    if (activate) {
      console.log('current size', size);

      fishIcon.style.display = "inline-block";

      if (size < 1.2) {
        // dragItem.classList.add("border-green")
        dragItem.classList.remove("border-yellow")
        dragItem.classList.remove("border-red")
      } else if (size >= 1.2 && size <= 1.3) {
        dragItem.classList.remove("border-green")
        dragItem.classList.add("border-yellow")
        dragItem.classList.remove("border-red")

        itemContainer.classList.remove("shake-slow")
        itemContainer.classList.add("shake-little")
        itemContainer.classList.add("shake-constant")
      } else if (size > 1.3 && size < 1.5) {
        dragItem.classList.remove("border-green")
        dragItem.classList.remove("border-yellow")
        dragItem.classList.add("border-red")
        itemContainer.classList.remove("shake-little")
        itemContainer.classList.add("shake-constant")
        itemContainer.classList.add("shake-slow")
      }
    } else {
      dragItem.classList.remove("border-green")
      dragItem.classList.remove("border-yellow")
      dragItem.classList.remove("border-red")
      itemContainer.classList.remove("shake-little")
      itemContainer.classList.remove("shake-constant")
      itemContainer.classList.remove("shake-slow")

      fishIcon.style.display = "none";
    }
  }

  function setState(state)
  {
    console.log('state changed: ' + game.state + ' -> ' + state)
    game.state = state
    updateDebug()
  }

</script>
</body>
</html>
